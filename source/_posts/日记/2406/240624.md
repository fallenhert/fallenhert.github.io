## 2024/06/24 星期一

### 工作内容

重新处理了上周五的那个问题，复盘发现并非是前端没有获取到后端传递的数据，而是另一个问题。

假定 res 对象下 value 原本值为 a，修改 value 值为 b。考虑通过`console.log()`在修改前打印 res 对象，以及 res.value 对象。通过翻找发现 res 对象中的 value 值为 b，而 res.value 值为 a。

```js
const res = {
  value: a,
};

console.log(res, res.value); // {value: b}  a

res.value = b;
```

解答：当你在浏览器控制台中打印一个对象时，你实际上看到的是对该对象的引用，而不是在打印时的快照。当你运行这段代码，在控制台点击之前打印出来的 obj 对象，你很可能会看到对象的最新状态，也就是{ value: 'b' }。尽管在语句执行的时候，对象的值是'a'。这是因为控制台展示的是对象引用所指向的内容，而这个内容在你点击检查它的时候才确定。

### 简记

刷了几道题，一道动态规划没看出来，一道回溯算法不清楚具体如何剪枝。

算手把手干掉的，只一道之前接触过的链表翻转问题。还是需要多练。
