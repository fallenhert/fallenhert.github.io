## 2024/06/19 星期三

### 工作内容

卡片重构的联调

新上了一个 tmp 拆分场景下的渲染和路由跳转

### 简记

参加了华为笔试。三道代码题，赋分分别为 100，200，300。明面上的差异化赋分。

第一题很简单，简单就手撕出来，没有什么印象。

第二题是盖印章。给一个印章数集和一个目标数集，要求盖印章盖出目标数集，并输出最少所需要的盖章数。印章可以覆盖，比如使用`[3, 2, 1]`的印章，盖两次就可以盖出`[3, 2, 3, 2, 1]`这样的目标数集，当然`[3, 2, 1, 1]`或者`[3, 3, 2, 1]`这样的都可以。

我一开始考虑的比较简单，想要从前往后遍历一遍，碰见与首字母不同的情况印章数`+1`。但通过率不高。后来我写出了`[3, 3, 1]`和`[3, 3, 3, 1, 1]`的用例，思路全乱了。最后通过率 95%。

第三题是一个图书馆里系统，支持增删查三种功能。通过最短前缀匹配来查询和删除书籍。如果最短前缀匹配没有查询到书籍或者查询到多个书籍，就不进行对应操作。

我认为这题思路上比较简单，考查的核心应该是最短前缀的匹配复杂度上。由于题目中给出的两个用例都是以`thebook`开头加上三位的随机字符串作为图书的标题，简单使用了后三位的随机字符串构建了`Map`来做处理。查找最短前缀的方法就是用的循环遍历搜索。这样仅过了 2 个用例，10%。

考虑后续用例可能并非均以`thebook`开头，增加上前缀后算法超时。长字符串的循环遍历搜索实在太过费时，但可惜没有积累过对应的解决策略。

> PS：210 抽吃了两个大保底，出了流萤和阮·梅
