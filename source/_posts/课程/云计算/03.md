---
title: Advanced Cloud
date: 2024/01/26
tags: [CUHK, 云计算]
categories: 课程
recommend: false
locate: 香港
copyright: 原创
mathjax: true
cover: /img/pageimage/0019.png
---

# Time Order

时序

## What is a "correct" order?

**Total order**: all replicas process messages in same order

同样的顺序、同样的状态 能够 输出同样的结果

Linearizability(线性化): total order + respect the real-time / total order follows real time

**FIFO order**: different servers can get different orders as long as _the order from the same client_ is preserved

(different servers can process in different orders but events from clients in same order)

**Causal ordering** tells the causal relationship between processes.

## Implementing total-order broadcast

Need a global sequencer(or elect a leader first)

Problem:

- if server 1 dies?
  - "atomic total-order broadcast" problem
- if the leader dies?
  - a leader election problem

## Implementing FIFO-order broadcast

Each client maintains its local counter(通过本地计数顺序执行)

Server maintains a queue for each client to order its messages

## More on the applications of ordering

Distributed mutex

System recovery

## Happen-Before Ordering

different processes P|Q|R

How to log a happen-before ordering among all events?

## Lamport's Logical Clock

LC 计数

- 每当本地事件发生的时候，LC 计数增加 1
- 当发送信息的时候，携带本地的 LC 计数
- 当收到信息的时候，修改本地的 LC 计数为 1 + max(LC, message's LC)

**Limitations of Logical Clock**

记录 x 事件发生的顺序为 LC(x)

如果 LC(x) < LC(y) => (i) x 可能在 y 之前发生 (ii) x 可能与 y 同时发生 (iii) x 不可能在 y 之后发生

## How to log a casual ordering among events ?

Vector Clock

if a < b <==> VC(a) < VC(b)

VC 计数，通过向量记录多个进程上面的计数

- 每当 i 进程发生本地事件时， VC(i)增加 1
- 每当 i 进程发送消息，在消息中携带其 VC 计数
- 每当 j 进程收到 i 进程发来的消息，更新 j 的 VC 计数，
  - 具体更新策略：将 j 的 VC 计数中 VC(j)增加 1，然后将 j 的 VC 计数中的每一个值，更新为 i 的 VC 计数和 j 的 VC 计数中的较大值

## Summary

**Ordering**

- Linearizability
- Total order
- FIFO ordering
- Causal ordering
- Happen-before ordering

**Clock**

## 实验
